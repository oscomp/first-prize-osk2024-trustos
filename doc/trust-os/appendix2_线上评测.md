# appendix2 线上评测

## 说在前面

往届队伍的文档很少有提到如果使自己的内核适配线上的评测系统，因此我专门开一个文档来讲一下自己的适配过程。同样，这个文档也是比赛结束后凭记忆写的，可能有一些不足，但应该能帮助大家少走一些弯路。


## 无网环境


线上评测的难点主要是它是一个无网的环境，并且比赛规定我们的内核必须在评测机上进行编译而不能提交已经编译好的可执行文件，以下几点都是在无网环境下编译可能遇到的问题。

- rCore的根目录下有一个`rust-toolchain.toml`文件，里面会指定工具链的版本，这是rust的一个特性，可以为每个项目指定版本，这个文件指定的版本会覆盖rustc的默认设置。如果这里指定的版本在机器中并没有安装的话，rust会自动从网上下载对应的版本。这就带来一个问题：线上评测系统是一个无网的环境，因此遇到版本不匹配，就会触发下载，然后一直等待到超时。这个问题很好解决，提交页面会写出评测机上已经安装的rustc的版本，我们只需要在`rust-toolchain.toml`中指定相同的版本就行了。（直接删除这个文件应该也可以，不过我没试过）
- rCore的Makefile里有一句`cargo install cargo-binutils`，这一句也是需要在有网环境下执行的。不过评测机已经预装了cargo-binutils，并不需要我们手动安装，所以直接把这句删掉即可（我们的os内核已经把这句删掉了）
- rust的离线编译。这一段我不确定有没有缺漏，大概过程是这样的：在os目录下先执行`cargo generate-lockfile`来生成一个lockfile，之后执行`cargo vendor`把远程包下载到本地（当前目录下会生成一个vendor目录），下载完后会有一个输出给你一段代码,比如
    ```Rust
    [source.crates-io]
    replace-with = "vendored-sources"

    [source.vendored-sources]
    directory = "vendor"
    ```
    把这段代码复制到当前目录的.cargo/config文件(没有这个文件就新建一个)里，就能在编译时使用本地的包。它的原理是，rust默认回去crates.io中寻找需要的包，而这段代码相当于把crates.io重定向到了本地的vendor目录，于是rust就会从vendor目录中寻找需要的包。
- .cargo目录。评测机再从gitlab上拉取代码时，会自动忽略隐藏文件（即以"."开头的文件），因此.cargo目录会被忽略，而我们离线编译需要的config文件正是在.cargo目录下。我们的解决方案是改名。上传到仓库时，将目录修改为dotcargo，这样评测机能成功拉取。之后修改makefile，在编译前将dotcargo重命名为.cargo，然后再进行编译，以此来解决问题。

## 指定镜像

评测机上使用的是官方的镜像，因此我们无法往镜像中添加额外的东西（比如我们启动应用程序时需要的`initproc`可执行文件）

对此我采用的是二进制内嵌的方法。将`initproc`的二进制文件作为一个字节数组内嵌到内核中，在内核启动后再通过文件调用将`initproc`写入到文件中。具体实现可以查看`os/src/fs/preload_qemu.S`文件和`os/src/fs/mod.rs`中的`flush_preload()`